# entities layer

FSD(Feature-Sliced Design) 기준에서 `entities`는 "도메인 개념"을 표현합니다.
네트워크 호출 및 외부 데이터 검증은 `entities` 내부의 `api`에서만 수행합니다.

---

## Best Practice Example (recipe)

실제 프로젝트의 `recipe` entity를 참고하세요.

```
src/entities/recipe/
  model/
    api/
      schema/
        recipeSchema.ts    # Zod 스키마 + 타입 추론
        enum.ts
      api.ts              # 네트워크 호출 + 검증 (유일한 검증 위치)
    useRecipe.ts          # TanStack Query 훅 + 쿼리 키
  index.ts                # Public API: 훅, 타입, enum, 쿼리키
  ui/
    RecipeCard.tsx        # (barrel 없음 - 직접 import)
```

**데이터 흐름:**
```
UI → Entity Hook → Entity API (Zod 검증) → Backend
```

**Public API (`index.ts`) 예시:**
```ts
// hooks - 기본 인터페이스
export { useRecipe, RECIPE_QUERY_KEY } from "./model/useRecipe";

// types - 도메인 타입 (내부 Response 타입 숨김)
export type { RecipeDto } from "./model/api/schema/recipeSchema";

// enums - 공유 열거형
export { RecipeSort } from "./model/api/schema/enum";
```

**API 노출 금지:**
```ts
// ❌ 하지 마세요 - API 함수 직접 노출
export { fetchRecipe } from "./model/api/api";

// ✅ 올바른 방법 - 훅을 통해 노출
export { useRecipe } from "./model/useRecipe";
```

---

## Recommended structure (generic)

```
src/entities/<entity>/
  model/
    api/
      schema/
        <entity>Schema.ts
        enum.ts
      api.ts
    use<Something>.ts
  index.ts
  ui/
    ... (no barrel rule)
```

Top-down rules:
- External imports go through `src/entities/<entity>/index.ts` only.
- `api.ts` is the only place that validates external data (`Schema.parse`).
- `model` exposes hooks and query keys.
- `ui` is reusable, but we do not enforce a barrel for bundle safety.

---

## Public API (`index.ts`)

`index.ts` is the single Public API entry for each entity.

What to export:
- Runtime: hooks, constants, query keys, enums
- Types: `export type { ... }`

Naming rule (public types):
- Do not expose types ending with `*Response` from entity `index.ts`.
- Prefer domain names (e.g. `User`, `Recipe`) or `*Dto` / `Paginated*`.
- If an internal type uses `*Response`, re-export it with an alias:
  - `export type { UserResponse as User } from "..."`

API exposure rule:
- Do NOT export `api.ts` functions from entity `index.ts`.
- The entity Public API should expose hooks (model layer) as the primary interface.
- Reason: keeping API functions internal prevents bypassing validation/selection conventions and reduces coupling to endpoints.

Why no `*.d.ts` as Public API:
- In TS, `*.d.ts` is typically used as generated output or ambient declarations.
- Using it as a hand-written Public API tends to cause friction with tooling, pathing, and refactors.
- A single `index.ts` entry is easier to maintain.

Query key rule:
- Query keys MUST be exported from `index.ts` (example: `*_QUERY_KEY as const`).
- Reason: feature/view/widget may need invalidate/refetch with the same key.

---

## model

`model` owns the domain-facing logic.

Responsibilities:
- Provide hooks for reading/writing entity data (TanStack Query recommended)
- Define query keys (`*_QUERY_KEY`) used by hooks

Allowed dependencies:
- Can depend on `model/api`

---

## model/api

`model/api` is the external boundary of the entity.

Responsibilities:
- Perform network calls
- Validate external data with Zod schemas
- Return validated data types

Internal modules:
- `schema/*`: Zod schemas and enums
  - Schema file defines runtime schema and its inferred type (`z.infer<typeof Schema>`)
  - Enum file defines shared enums used by schema/api/model
- `api.ts`: calls backend and validates with `Schema.parse` (or `parseWithErrLog`)

Type export rule:
- Types exposed from `index.ts` SHOULD come from `schema/*` files where they are defined as `z.infer<typeof SomeSchema>`.
- Avoid defining DTO types ad-hoc in `index.ts`.
  - Reason: `index.ts` is the Public API surface; the source of truth for external data shape is the Zod schema.
  - Pattern: `schema/*.ts` exports both `SomeSchema` (runtime) and `SomeDto` (type), then `index.ts` re-exports `SomeDto` via `export type { ... }`.

Why validation lives here:
- If validation is scattered across layers (UI parsing, feature parsing), it creates duplication and inconsistent guarantees.
- Putting all validation in `api.ts` makes the "data contract" explicit and centralized.

---

## ui (no barrel rule)

`ui` contains reusable components for the entity.

Rule:
- We do NOT enforce `ui/index.ts` barrel exports.

Reason:
- UI barrels can encourage wide imports that accidentally pull in more modules than needed.
- Keeping explicit import paths helps bundle hygiene and avoids import surface creep.

---

## Exception: shared schema module

Some schemas/utilities are shared across multiple entities.
In that case, a dedicated module like `src/entities/schema` may exist.

Rules still apply:
- `src/entities/schema/index.ts` is its Public API
- Types are exposed via `export type { ... }` in that `index.ts`
- Entity `model/api/api.ts` imports shared schemas and performs validation

---

## 장점

1. **명확한 계층 분리**
   - Public API(`index.ts`)와 내부 구현이 명확히 분리
   - 외부에서는 훅을 통해 데이터에 접근하므로 구현 변경에 영향이 적음

2. **단일 검증 지점**
   - `api.ts`에서만 검증하므로 데이터 계약이 명확
   - Zod 스키마가 타입의 단일 소스 (Single Source of Truth)

3. **쿼리 키 중앙화**
   - Entity에서 쿼리 키를 관리하므로 무효화/재조회가 용이
   - 중복 쿼리 키 생성 방지

---

## 단점

1. **초기 설정 복잡성**
   - 처음 entity를 생성할 때 폴더 구조가 상세함
   - 작은 entity에는 과도한 구조처럼 느껴질 수 있음

2. **간접적으로 인해 파일 탐색 증가**
   - `import` 경로가 길어질 수 있음 (`@/src/entities/recipe/model/useRecipe`)
   - IDE 기능(Symbol search, Go to Definition)으로 완화 필요

---

## 단점에 대한 해결 가이드

### 문제: 작은 entity에 과도한 구조

**해결 방안:**
- entity가 정말 작으면 `model/api/`와 `model/`를 한 단계로 합치기보다
- 프로젝트 전체 일관성을 위해 구조 유지 (나중에 성장할 수 있음)

### 문제: import 경로 길이

**해결 방안:**
- IDE의 "Import Path Shortening" 기능 활용
- 필요시 path alias 활용 (`@/entities/recipe`)

### 문제: boilerplate 코드

**해결 방안:**
- Entity 스캐폴드/snippet 활용
- 코드 생성기 도입 고려 (프로젝트 규모가 큰 경우)

---

## 각 모듈의 역할과 예시

### `index.ts` - Public API 진입점

Entity의 유일한 Public API입니다.

**역할:**
- 외부(UI/feature/widget)에 노출할 훅, 타입, enum, 쿼리키 내보내기
- 내부 구현(API 함수 등)을 숨기고 인터페이스만 제공

**예시:**
```ts
// hooks - 데이터 조회/변경 인터페이스
export { useRecipe, RECIPE_QUERY_KEY } from "./model/useRecipe";

// types - 도메인 타입 (내부 Response 타입 숨김)
export type { RecipeDto } from "./model/api/schema/recipeSchema";

// enums - 공유 열거형
export { RecipeSort } from "./model/api/schema/enum";

// ❌ 하지 마세요 - API 함수 직접 노출
// export { fetchRecipe } from "./model/api/api";
```

---

### `model/` - 도메인 로직 계층

Entity의 비즈니스 로직을 담당합니다.

**역할:**
- TanStack Query 훅 제공 (데이터 조회/변경)
- 쿼리 키 정의
- 데이터 선택/변형 로직

**예시:**
```ts
// model/useRecipe.ts
import { useSuspenseQuery } from "@tanstack/react-query";
import { fetchRecipe } from "./api/api";

export const RECIPE_QUERY_KEY = ["recipe"] as const;

export function useRecipe(id: string) {
  return useSuspenseQuery({
    queryKey: [...RECIPE_QUERY_KEY, id],
    queryFn: () => fetchRecipe(id),
    select: (data) => ({
      // 필요한 필드만 선택하거나 변형
      title: data.recipeTitle,
      thumbnail: data.videoThumbnailUrl,
    }),
  });
}

export function useCreateRecipe() {
  return useMutation({
    mutationFn: async (url: string) => createRecipe(url),
    onSuccess: () => {
      // 관련 쿼리 무효화
      queryClient.invalidateQueries({ queryKey: RECIPE_QUERY_KEY });
    },
  });
}
```

---

### `model/api/` - 외부 경계 계층

백엔드와 통신하고 데이터를 검증하는 유일한 위치입니다.

**역할:**
- HTTP 요청 수행
- Zod 스키마로 응답 검증
- 검증된 타입 반환

**내부 구조:**
```
model/api/
  schema/
    recipeSchema.ts    # Zod 스키마 + 타입 추론
    enum.ts            # 공용 열거형
  api.ts              # API 함수 + 검증 (유일한 검증 위치)
```

**예시:**
```ts
// model/api/schema/recipeSchema.ts
import { z } from "zod";

export const RecipeSchema = z.object({
  recipeId: z.string(),
  recipeTitle: z.string(),
  videoThumbnailUrl: z.string().url(),
});

export type RecipeDto = z.infer<typeof RecipeSchema>;
```

```ts
// model/api/api.ts
import client from "@/src/shared/client/main/client";
import { RecipeSchema } from "./schema/recipeSchema";
import { parseWithErrLog } from "@/src/entities/schema/logger/zodErrorLogger";

export async function fetchRecipe(id: string): Promise<RecipeDto> {
  const res = await client.get(`/recipe/${id}`);
  return parseWithErrLog(RecipeSchema, res.data);
}
```

**검증이 여기에만 있는 이유:**
- 검증이 흩어지면(data 파싱이 UI/feature에서 발생) 중복과 불일치 발생
- 모든 검증을 `api.ts`에 모으면 "데이터 계약"이 명확해지고 중앙화됨

---

### `ui/` - 재사용 가능한 UI 컴포넌트

Entity와 관련된 재사용 가능 UI 컴포넌트입니다.

**규칙:**
- `ui/index.ts` barrel export를 하지 않음 (bundle 최적화)
- 직접 import 경로 사용

**예시:**
```ts
// ui/RecipeCard.tsx
export function RecipeCard({ recipeId }: Props) {
  const { data } = useRecipe(recipeId);
  return <div>{data.recipeTitle}</div>;
}
```

```ts
// 사용처에서 직접 import
import RecipeCard from "@/src/entities/recipe/ui/RecipeCard";
```

---

## 주의사항

### ⚠️ API 함수 직접 호출 금지

Entity 외부에서 `model/api/api.ts`의 함수를 직접 호출하지 마세요. 항상 `model/`의 훅을 통해 접근해야 합니다.

```ts
// ❌ 하지 마세요 - API 함수 직접 호출
import { fetchRecipe } from "@/src/entities/recipe/model/api/api";
const data = await fetchRecipe(id);

// ✅ 올바른 방법 - 훅 사용
import { useRecipe } from "@/src/entities/recipe";
const { data } = useRecipe(id);
```

**이유:**
- 훅을 통해 캐싱, 무효화, 로딩 상태 등 React Query 기능 활용
- 검증 로직 우회 방지
- 추후 API 변경 시 훅만 수정하면 됨

### ⚠️ 타입 네이밍 규칙

Public API에서는 도메인 네이밍을 사용하세요. `*Response` 타입을 직접 노출하지 마세요.

```ts
// ❌ 하지 마세요 - Response 타입 직접 노출
export type { RecipeResponse } from "./model/api/api";

// ✅ 올바른 방법 - 도메인 네이밍 또는 별칭 사용
export type { RecipeResponse as Recipe } from "./model/api/api";
// 또는
export type { RecipeDto } from "./model/api/schema/recipeSchema";
```

### ⚠️ Validation 위치

데이터 검증은 `model/api/api.ts`에서만 수행하세요. UI나 feature 레이어에서 `z.parse()`를 호출하지 마세요.

```ts
// ❌ 하지 마세요 - UI에서 검증
const parsed = RecipeSchema.safeParse(serverData);

// ✅ 올바른 방법 - api.ts에서 검증된 결과 사용
const { data } = useRecipe(); // 이미 검증된 데이터
```
