# views layer

FSD(Feature-Sliced Design) 기준에서 `views`는 **PAGE** 슬라이스에 해당합니다. 각 뷰는 Next.js 라우팅을 위한 페이지 진입점(`index.tsx`)과 반응형 UI 컴포넌트로 구성됩니다.

---

## Architecture Pattern

### Best Practice: Responsive Switcher Pattern

각 뷰는 **기기 유형별 UI 분리**를 통해 모바일/태블릿/데스크톱 최적화를 제공합니다.

```
src/views/<view-name>/
  index.tsx                    # ResponsiveSwitcher로 분기
  common/                    # (선택) 공통 컴포넌트/로직
    hook/
        <hookName1>.tablet.tsx
    component/
        <ComponentName1>.tablet.tsx
        <ComponentName2>.tablet.tsx
  mobile/
    index.mobile.tsx        # 모바일 전용 UI
    hook/
        <hookName1>.tablet.tsx
    component/
        <ComponentName1>.tablet.tsx
        <ComponentName2>.tablet.tsx
  tablet/
    index.tablet.tsx        # 태블릿 전용 UI 
    hook/
        <hookName1>.tablet.tsx
    component/
        <ComponentName1>.tablet.tsx
        <ComponentName2>.tablet.tsx
  desktop/
  index.desktop.tsx        # 데스크톱 전용 UI 
    hook/
        <hookName1>.tablet.tsx
    component/
        <ComponentName1>.desktop.tsx
        <ComponentName2>.tablet.tsx
```

### 핵심 원칙

1. **`index.tsx`**: Next.js 페이지 엔트리포인트로, 라우팅 정의
2. **`ui/index.tsx`**: `ResponsiveSwitcher`로 기기별 컴포넌트 분기
3. **`mobile/`, `tablet/`, `desktop/`**: 각 기기 UI 구현 (선택 - 필요한 경우만)

---

## ResponsiveSwitcher 분기

`ui/index.tsx`에서 `ResponsiveSwitcher` 컴포넌트를 사용해 기기별 UI를 분기합니다.

```tsx
// src/views/<view>/ui/index.tsx
import { ResponsiveSwitcher } from "@/src/shared/ui/responsive";
import { ViewPageMobile } from "./mobile/View.mobile";
import { ViewPageTablet } from "./tablet/View.tablet";
import { ViewPageDesktop } from "./desktop/View.desktop";

export const ViewPageReady = ({ id }: { id: string }) => {
  return (
    <ResponsiveSwitcher
      mobile={ViewPageMobile}
      tablet={ViewPageTablet}
      desktop={ViewPageDesktop}
      props={{ id }}
    />
  );
};

export const ViewPageSkeleton = () => {
  return (
    <ResponsiveSwitcher
      mobile={ViewPageSkeletonMobile}
      tablet={ViewPageSkeletonTablet}
      desktop={ViewPageSkeletonDesktop}
      props={{}}
    />
  );
};
```

### ResponsiveSwitcher 내부 동작

- **모바일**: `< 768px` → `mobile` 컴포넌트 렌더링
- **데스크톱**: `>= 1024px` → `desktop` 컴포넌트 렌더링
- **태블릿**: 그 외 (768px ~ 1023px) → `tablet` 컴포넌트 렌더링

---

## 각 모듈의 역할

### `index.tsx` (페이지 엔트리)

Next.js 라우터가 진입하는 페이지 파일입니다.

역할:
- Error Boundary, Suspense 등 페이지 레벨 래퍼 제공
- URL 파라미터 추출 및 페이지 컴포넌트로 전달
- 페이지별 인증/권한 체크

```tsx
// src/views/<view>/index.tsx
import { ViewPageReady, ViewPageSkeleton } from "./ui";
import { SSRSuspense } from "@/src/shared/boundary/SSRSuspense";

export default function ViewPage() {
  return (
    <SSRSuspense fallback={<ViewPageSkeleton />}>
      <ViewPageReady />
    </SSRSuspense>
  );
}
```

### `ui/index.tsx` (Response Switcher)

기기별 컴포넌트를 분기하는 허브입니다.

역할:
- `ResponsiveSwitcher`로 기기별 컴포넌트 선택
- 페이지 Ready/Skeleton 상태 내보내기

### `ui/common/` (선택)

뷰 내부에서 공통으로 사용되는 컴포넌트와 로직입니다.

역할:
- **controller**: 비즈니스 로직, 상태 관리, 이벤트 핸들러
- **공통 UI**: 기기 간 공유 UI 컴포넌트

```tsx
// src/views/<view>/ui/common/controller.ts
export function useViewController(id: string) {
  const { data } = useSomeEntity(id);
  const handleClick = () => { /* ... */ };
  return { data, handleClick };
}
```

### `ui/mobile/`, `ui/tablet/`, `ui/desktop/`

각 기기에 최적화된 UI를 구현합니다.

역할:
- 기기별 레이아웃, 스타일, 인터랙션 구현
- `common/controller`의 로직을 사용해 UI 렌더링

```tsx
// src/views/<view>/ui/mobile/View.mobile.tsx
import { useViewController } from "../common/controller";

export function ViewPageMobile({ id }: { id: string }) {
  const { data, handleClick } = useViewController(id);
  return (
    <div className="mobile-only-styles">
      <button onClick={handleClick}>모바일 버튼</button>
    </div>
  );
}
```

---

## 대안: 조건부 렌더링 (기기 유형이 2개인 경우)

모바일/데스크톱만 필요한 경우 `ResponsiveSwitcher` 대신 조건부 렌더링을 사용할 수 있습니다.

```tsx
// src/views/<view>/ui/index.tsx
import { ViewPageMobile } from "./mobile/View.mobile";
import { ViewPageDesktop } from "./desktop/View.desktop";

export function ViewPageReady(props: ViewProps) {
  const isDesktop = useMediaQuery(MEDIA_QUERIES.desktop);
  return isDesktop ? <ViewPageDesktop {...props} /> : <ViewPageMobile {...props} />;
}
```

---

## 장점

1. **기기별 UI 최적화**
   - 모바일/태블릿/데스크톱 각각에 최적화된 레이아웃 제공
   - 미디어 쿼리가 섞인 복잡한 JSX를 피함

2. **명확한 관심사 분리**
   - 기기별 UI 코드가 완전히 분리되어 독립적으로 개발 가능
   - `common/`에서 공통 로직을 관리하여 중복 최소화

3. **유지보수성**
   - 특정 기기 UI 수정 시 해당 파일만 변경
   - 기기 추가/제거가 용이

---

## 단점

1. **파일 수 증가**
   - 기기별 파일이 별도로 존재하여 파일 수가 늘어남
   - 프로젝트 규모가 커지면 파일 탐색 비용 증가

2. **코드 중복 가능성**
   - `common/` 분리가 미흡할 경우 유사 코드가 반복될 수 있음
   - 기기 간 UI가 90% 유사한 경우 분리의 이득이 미미함

---

## 단점에 대한 해결 가이드

### 문제: 파일 수 증가로 인한 탐색 어려움

**해결 방안:**
- IDE의 파일 네비게이션 활용 (Symbol search, Go to Definition)
- 관련 파일을 그룹핑: `<View>.mobile.tsx`, `<View>.tablet.tsx`, `<View>.desktop.tsx`

### 문제: 기기 간 코드 중복

**해결 방안 1: 공통 로직을 `common/controller.ts`로 분리**
```tsx
// hooks/controller.ts
export function useViewController(id: string) {
  const { data } = useSomeEntity(id);
  const handleClick = () => { /* 공통 로직 */ };
  return { data, handleClick };
}

// mobile/View.mobile.tsx
export function ViewPageMobile({ id }: { id: string }) {
  const { data, handleClick } = useViewController(id);
  return <div className="mobile-layout" onClick={handleClick}>{data}</div>;
}

// desktop/View.desktop.tsx
export function ViewPageDesktop({ id }: { id: string }) {
  const { data, handleClick } = useViewController(id);
  return <div className="desktop-layout" onClick={handleClick}>{data}</div>;
}
```

**해결 방안 2: 90% 유사한 경우 단일 파일 + 미디어 쿼리 사용**
```tsx
// ui/index.tsx
export function ViewPageReady({ id }: { id: string }) {
  const isDesktop = useMediaQuery(MEDIA_QUERIES.desktop);
  const { data, handleClick } = useViewController(id);

  return (
    <div className={isDesktop ? "desktop-layout" : "mobile-layout"}>
      <SharedComponent onClick={handleClick} />
      {isDesktop && <DesktopOnlyFeature />}
    </div>
  );
}
```

**해결 방안 3: 공통 UI 컴포넌트를 `common/`로 분리**
```tsx
// common/SharedCard.tsx
export function SharedCard({ title, onClick }) {
  return (
    <div className="card-base" onClick={onClick}>
      <h3>{title}</h3>
    </div>
  );
}

// mobile/View.mobile.tsx
import { SharedCard } from "../common/SharedCard";
export function ViewPageMobile() {
  return <SharedCard title="모바일" className="mobile-card" />;
}
```

---

## 주의사항

### ⚠️ 아직 패턴이 적용되지 않은 뷰

현재 프로젝트에 아직 ResponsiveSwitcher 패턴이 적용되지 않은 뷰가 있습니다. 새로운 뷰를 추가하거나 수정할 때는 위 패턴을 따라주세요.

**패턴 적용 체크리스트:**
- [ ] `index.tsx`가 페이지 진입점인가?
- [ ] `ui/index.tsx`가 `ResponsiveSwitcher`를 사용하는가?
- [ ] 공통 로직이 `common/`에 있는가?
- [ ] 기기별 UI가 각각 `mobile/`, `tablet/`, `desktop/`에 있는가?

---

## 예시: 구조화된 뷰

```
src/views/recipe-detail/
  index.tsx                    # 페이지 진입점 (Error Boundary, Suspense)
  ui/
    index.tsx                  # ResponsiveSwitcher 분기
    common/
      controller.ts            # 비즈니스 로직
      IngredientPurchaseModal.tsx
    mobile/
      RecipeDetail.mobile.tsx  # 모바일 UI
    tablet/
      RecipeDetail.tablet.tsx  # 태블릿 UI
    desktop/
      RecipeDetail.desktop.tsx # 데스크톱 UI
  hooks/
    useRecipeDetailTranslation.ts
```

---

## ⚠️ 추가 주의사항

### 기기별 파일의 선택성

`mobile/`, `tablet/`, `desktop/` 폴더는 선택사항입니다. 프로젝트 요구에 따라:

- **모바일만 필요**: `mobile/`만 생성
- **모바일/데스크톱만 필요**: `tablet/` 없이 진행 가능
- **모두 필요**: 세 폴더 모두 생성

`ResponsiveSwitcher`에 해당 컴포넌트가 없는 경우, 대체 컴포넌트를 사용하거나 fallback을 제공하세요.

```tsx
// tablet이 없는 경우 mobile을 fallback으로 사용
export const ViewPageReady = ({ id }: { id: string }) => {
  return (
    <ResponsiveSwitcher
      mobile={ViewPageMobile}
      tablet={ViewPageMobile}  // fallback to mobile
      desktop={ViewPageDesktop}
      props={{ id }}
    />
  );
};
```

### 비즈니스 로직의 위치

뷰 관련 비즈니스 로직은 `ui/common/controller.ts`에 배치하세요. 페이지 레벨 로직이 필요하면 `index.tsx`에서 처리합니다.

- **controller.ts**: 뷰 내부 공통 로직 (상태 관리, 이벤트 핸들러)
- **index.tsx**: 페이지 래퍼 (Error Boundary, Suspense, 라우팅)

### 페이지 탐색 시간 단축

관련 파일을 빠르게 찾기 위해:
- `mobile/View.mobile.tsx`
- `tablet/View.tablet.tsx`
- `desktop/View.desktop.tsx`

같은 파일명 접두사를 사용하세요. IDE에서 파일 검색 시 `View.tsx`만 입력해도 관련 파일이 그룹핑되어 표시됩니다.
